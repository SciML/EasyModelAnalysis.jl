<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ensemble Modeling · EasyModelAnalysis.jl</title><meta name="title" content="Ensemble Modeling · EasyModelAnalysis.jl"/><meta property="og:title" content="Ensemble Modeling · EasyModelAnalysis.jl"/><meta property="twitter:title" content="Ensemble Modeling · EasyModelAnalysis.jl"/><meta name="description" content="Documentation for EasyModelAnalysis.jl."/><meta property="og:description" content="Documentation for EasyModelAnalysis.jl."/><meta property="twitter:description" content="Documentation for EasyModelAnalysis.jl."/><meta property="og:url" content="https://docs.sciml.ai/EasyModelAnalysis/stable/tutorials/ensemble_modeling/"/><meta property="twitter:url" content="https://docs.sciml.ai/EasyModelAnalysis/stable/tutorials/ensemble_modeling/"/><link rel="canonical" href="https://docs.sciml.ai/EasyModelAnalysis/stable/tutorials/ensemble_modeling/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="EasyModelAnalysis.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">EasyModelAnalysis.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">EasyModelAnalysis.jl: Quick and Easy Queries to Simulation Results</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started with EasyModelAnalysis</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../sensitivity_analysis/">Sensitivity Analysis</a></li><li><a class="tocitem" href="../datafitting/">Calibrating Models to Data</a></li><li><a class="tocitem" href="../threshold_interventions/">Designing Threshold Interventions</a></li><li><a class="tocitem" href="../probabilistic_thresholds/">Analysis of Threshold Crossing Probabilities Under Uncertainty</a></li><li class="is-active"><a class="tocitem" href>Ensemble Modeling</a><ul class="internal"><li><a class="tocitem" href="#The-Predictive-Models"><span>The Predictive Models</span></a></li><li><a class="tocitem" href="#Representing-Ensemble-Models-with-the-SciML-EnsembleProblem"><span>Representing Ensemble Models with the SciML EnsembleProblem</span></a></li><li><a class="tocitem" href="#Building-a-Dataset"><span>Building a Dataset</span></a></li><li><a class="tocitem" href="#Bayesian-Calibration"><span>Bayesian Calibration</span></a></li><li><a class="tocitem" href="#Training-the-Ensemble-Model"><span>Training the Ensemble Model</span></a></li><li><a class="tocitem" href="#Forecasting-the-Trained-Ensemble"><span>Forecasting the Trained Ensemble</span></a></li></ul></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/petri/">AlgebraicPetri Integration</a></li><li><a class="tocitem" href="../../examples/ASIR/">Analysis of The Asymptomatic SIR Model</a></li><li><a class="tocitem" href="../../examples/SEIRHD/">Analysis of Interventions On The SEIRHD Epidemic Model</a></li><li><a class="tocitem" href="../../examples/Carcione2020/">Sensitivity Analysis of the Carcione2020 Epidemic Model</a></li></ul></li><li><span class="tocitem">Scenarios</span><ul><li><a class="tocitem" href="../../scenarios/scenario1/">Scenario 1: Vaccination</a></li><li><a class="tocitem" href="../../scenarios/scenario2/">Scenario 2: Limiting Hospitalizations</a></li><li><a class="tocitem" href="../../scenarios/scenario3/">Scenario 3: Limiting Deaths</a></li><li><a class="tocitem" href="../../scenarios/scenario4/">Scenario 4: Testing and Return to Campus</a></li><li><a class="tocitem" href="../../scenarios/scenario5/">Scenario 5: Bucky model</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../api/basic_queries/">Basic Queries</a></li><li><a class="tocitem" href="../../api/data_fitting_calibration/">Data Fitting and Model Calibration</a></li><li><a class="tocitem" href="../../api/sensitivity_analysis/">Sensitivity Analysis</a></li><li><a class="tocitem" href="../../api/threshold_interventions/">Threshold Interventions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Ensemble Modeling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Ensemble Modeling</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/EasyModelAnalysis.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/EasyModelAnalysis.jl/blob/main/docs/src/tutorials/ensemble_modeling.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Ensemble-Modeling"><a class="docs-heading-anchor" href="#Ensemble-Modeling">Ensemble Modeling</a><a id="Ensemble-Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Ensemble-Modeling" title="Permalink"></a></h1><p>Ensemble modeling is the process of building predictors which are combinations of predictive models. In this tutorial we will show how to use EMA.jl to build such ensemble models.</p><h2 id="The-Predictive-Models"><a class="docs-heading-anchor" href="#The-Predictive-Models">The Predictive Models</a><a id="The-Predictive-Models-1"></a><a class="docs-heading-anchor-permalink" href="#The-Predictive-Models" title="Permalink"></a></h2><p>For this tutorial we will use a set of SIR-type models as the basis. In particular, we will use a basic SIR model, an SIRHD, and an SIRHD model with vaccintation. The construction of the models is as follows:</p><pre><code class="language-julia hljs">using EasyModelAnalysis, LinearAlgebra

@parameters t β=0.05 c=10.0 γ=0.25
@variables S(t)=990.0 I(t)=10.0 R(t)=0.0
∂ = Differential(t)
N = S + I + R # This is recognized as a derived variable
eqs = [∂(S) ~ -β * c * I / N * S,
    ∂(I) ~ β * c * I / N * S - γ * I,
    ∂(R) ~ γ * I];

@named sys = ODESystem(eqs);
tspan = (0, 30)
prob = ODEProblem(sys, [], tspan);

@parameters t β=0.1 c=10.0 γ=0.25 ρ=0.1 h=0.1 d=0.1 r=0.1
@variables S(t)=990.0 I(t)=10.0 R(t)=0.0 H(t)=0.0 D(t)=0.0
∂ = Differential(t)
N = S + I + R + H + D # This is recognized as a derived variable
eqs = [∂(S) ~ -β * c * I / N * S,
    ∂(I) ~ β * c * I / N * S - γ * I - h * I - ρ * I,
    ∂(R) ~ γ * I + r * H,
    ∂(H) ~ h * I - r * H - d * H,
    ∂(D) ~ ρ * I + d * H];

@named sys2 = ODESystem(eqs);

prob2 = ODEProblem(sys2, [], tspan);

@parameters t β=0.1 c=10.0 γ=0.25 ρ=0.1 h=0.1 d=0.1 r=0.1 v=0.1
@parameters t β2=0.1 c2=10.0 ρ2=0.1 h2=0.1 d2=0.1 r2=0.1
@variables S(t)=990.0 I(t)=10.0 R(t)=0.0 H(t)=0.0 D(t)=0.0
@variables Sv(t)=0.0 Iv(t)=0.0 Rv(t)=0.0 Hv(t)=0.0 Dv(t)=0.0
@variables I_total(t)

∂ = Differential(t)
N = S + I + R + H + D + Sv + Iv + Rv + Hv + Dv # This is recognized as a derived variable
eqs = [∂(S) ~ -β * c * I_total / N * S - v * Sv,
    ∂(I) ~ β * c * I_total / N * S - γ * I - h * I - ρ * I,
    ∂(R) ~ γ * I + r * H,
    ∂(H) ~ h * I - r * H - d * H,
    ∂(D) ~ ρ * I + d * H,
    ∂(Sv) ~ -β2 * c2 * I_total / N * Sv + v * Sv,
    ∂(Iv) ~ β2 * c2 * I_total / N * Sv - γ * Iv - h2 * Iv - ρ2 * Iv,
    ∂(Rv) ~ γ * I + r2 * H,
    ∂(Hv) ~ h2 * I - r2 * H - d2 * H,
    ∂(Dv) ~ ρ2 * I + d2 * H,
    I_total ~ I + Iv,
];

@named sys3 = ODESystem(eqs)
sys3 = structural_simplify(sys3)
prob3 = ODEProblem(sys3, [], tspan);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">ODEProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Vector{Float64}</span> and tType <span class="sgr38_2" style="color:#56b6c2">Int64</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">true</span>
timespan: (0, 30)
u0: 10-element Vector{Float64}:
 990.0
  10.0
   0.0
   0.0
   0.0
   0.0
   0.0
   0.0
   0.0
   0.0</code></pre><h2 id="Representing-Ensemble-Models-with-the-SciML-EnsembleProblem"><a class="docs-heading-anchor" href="#Representing-Ensemble-Models-with-the-SciML-EnsembleProblem">Representing Ensemble Models with the SciML EnsembleProblem</a><a id="Representing-Ensemble-Models-with-the-SciML-EnsembleProblem-1"></a><a class="docs-heading-anchor-permalink" href="#Representing-Ensemble-Models-with-the-SciML-EnsembleProblem" title="Permalink"></a></h2><p>The SciML libraries allow for what&#39;s known as an <code>EnsembleProblem</code>, which is an object that solves many simultainous problems and represents the aggregate solution. This object is documented <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/ensemble/">in the DifferentialEquations.jl documentation</a> and has all kinds of features, such as automated GPU acceleration, though we will instead focus just on the subset of features required for this demonstration. To build an EnsembleProblem, the main object is the <code>prob_func</code>, which is a function of <code>(prob,i,repeat)</code> which describes what the <code>i</code>th problem should be. The <code>prob</code> in this case is a prototype problem, which we are effectively ignoring for our use case.</p><p>Thus a simple <code>EnsembleProblem</code> which ensembles the three models built above is as follows:</p><pre><code class="language-julia hljs">probs = [prob, prob2, prob3]
enprob = EnsembleProblem(probs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EnsembleProblem with problem Array</code></pre><p>Here, <code>prob_func</code> returns model <code>i</code> on the <code>i</code>th iteration, and thus if we solve with 3 trajectories we will get the solution to all three models. This looks like:</p><pre><code class="language-julia hljs">sol = solve(enprob; saveat = 1);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EnsembleSolution Solution of length 3 with uType:
ODESolution{Float64, 2, Vector{Vector{Float64}}, Nothing, Nothing, Vector{Float64}, Vector{Vector{Vector{Float64}}}, ODEProblem{Vector{Float64}, Tuple{Float64, Float64}, true, Vector{Float64}, ODEFunction{true, SciMLBase.AutoSpecialize, FunctionWrappersWrappers.FunctionWrappersWrapper{Tuple{FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64}}, FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{Float64}, Float64}}, FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{Float64}, Vector{Float64}, ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}}, FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{Float64}, ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}}}, false}, LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Vector{Symbol}, Symbol, Vector{Symbol}, ModelingToolkit.var&quot;#630#generated_observed#555&quot;{Bool, ODESystem, Dict{Any, Any}, Vector{SymbolicUtils.BasicSymbolic{Real}}}, Nothing, ODESystem}, Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}, SciMLBase.StandardODEProblem}, CompositeAlgorithm{Tuple{Tsit5{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}, Rosenbrock23{1, false, Nothing, typeof(OrdinaryDiffEq.DEFAULT_PRECS), Val{:forward}, true, nothing}}, OrdinaryDiffEq.AutoSwitchCache{Tsit5{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}, Rosenbrock23{0, false, Nothing, typeof(OrdinaryDiffEq.DEFAULT_PRECS), Val{:forward}, true, nothing}, Rational{Int64}, Int64}}, OrdinaryDiffEq.CompositeInterpolationData{ODEFunction{true, SciMLBase.AutoSpecialize, FunctionWrappersWrappers.FunctionWrappersWrapper{Tuple{FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64}}, FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{Float64}, Float64}}, FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{Float64}, Vector{Float64}, ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}}, FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{Float64}, ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}}}, false}, LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Vector{Symbol}, Symbol, Vector{Symbol}, ModelingToolkit.var&quot;#630#generated_observed#555&quot;{Bool, ODESystem, Dict{Any, Any}, Vector{SymbolicUtils.BasicSymbolic{Real}}}, Nothing, ODESystem}, Vector{Vector{Float64}}, Vector{Float64}, Vector{Vector{Vector{Float64}}}, OrdinaryDiffEq.CompositeCache{Tuple{OrdinaryDiffEq.Tsit5Cache{Vector{Float64}, Vector{Float64}, Vector{Float64}, typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}, OrdinaryDiffEq.Rosenbrock23Cache{Vector{Float64}, Vector{Float64}, Vector{Float64}, Matrix{Float64}, Matrix{Float64}, OrdinaryDiffEq.Rosenbrock23Tableau{Float64}, SciMLBase.TimeGradientWrapper{ODEFunction{true, SciMLBase.AutoSpecialize, FunctionWrappersWrappers.FunctionWrappersWrapper{Tuple{FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64}}, FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{Float64}, Float64}}, FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{Float64}, Vector{Float64}, ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}}, FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{Float64}, ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}}}, false}, LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Vector{Symbol}, Symbol, Vector{Symbol}, ModelingToolkit.var&quot;#630#generated_observed#555&quot;{Bool, ODESystem, Dict{Any, Any}, Vector{SymbolicUtils.BasicSymbolic{Real}}}, Nothing, ODESystem}, Vector{Float64}, Vector{Float64}}, SciMLBase.UJacobianWrapper{ODEFunction{true, SciMLBase.AutoSpecialize, FunctionWrappersWrappers.FunctionWrappersWrapper{Tuple{FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64}}, FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{Float64}, Float64}}, FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{Float64}, Vector{Float64}, ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}}, FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{Float64}, ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}}}, false}, LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Vector{Symbol}, Symbol, Vector{Symbol}, ModelingToolkit.var&quot;#630#generated_observed#555&quot;{Bool, ODESystem, Dict{Any, Any}, Vector{SymbolicUtils.BasicSymbolic{Real}}}, Nothing, ODESystem}, Float64, Vector{Float64}}, LinearSolve.LinearCache{Matrix{Float64}, Vector{Float64}, Vector{Float64}, SciMLBase.NullParameters, LinearSolve.DefaultLinearSolver, LinearSolve.DefaultLinearSolverInit{LinearAlgebra.LU{Float64, Matrix{Float64}, Vector{Int64}}, LinearAlgebra.QRCompactWY{Float64, Matrix{Float64}, Matrix{Float64}}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, LinearAlgebra.LU{Float64, Matrix{Float64}, Vector{Int64}}, Tuple{LinearAlgebra.LU{Float64, Matrix{Float64}, Vector{Int64}}, Vector{Int64}}, Nothing, Nothing, Nothing, LinearAlgebra.SVD{Float64, Float64, Matrix{Float64}, Vector{Float64}}, LinearAlgebra.Cholesky{Float64, Matrix{Float64}}, LinearAlgebra.Cholesky{Float64, Matrix{Float64}}, Tuple{LinearAlgebra.LU{Float64, Matrix{Float64}, Vector{Int32}}, Base.RefValue{Int32}}, Tuple{LinearAlgebra.LU{Float64, Matrix{Float64}, Vector{Int64}}, Base.RefValue{Int64}}}, LinearSolve.InvPreconditioner{LinearAlgebra.Diagonal{Float64, Vector{Float64}}}, LinearAlgebra.Diagonal{Float64, Vector{Float64}}, Float64, Bool}, FiniteDiff.JacobianCache{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, UnitRange{Int64}, Nothing, Val{:forward}(), Float64}, FiniteDiff.GradientCache{Nothing, Vector{Float64}, Vector{Float64}, Float64, Val{:forward}(), Float64, Val{true}()}, Float64, Rosenbrock23{1, false, Nothing, typeof(OrdinaryDiffEq.DEFAULT_PRECS), Val{:forward}, true, nothing}, Nothing}}, OrdinaryDiffEq.AutoSwitchCache{Tsit5{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}, Rosenbrock23{0, false, Nothing, typeof(OrdinaryDiffEq.DEFAULT_PRECS), Val{:forward}, true, nothing}, Rational{Int64}, Int64}}}, DiffEqBase.Stats, Vector{Int64}}</code></pre><p>We can access the 3 solutions as <code>sol[i]</code> respectively. Let&#39;s get the time series for <code>S</code> from each of the models:</p><pre><code class="language- hljs">sol[:,S]</code></pre><h2 id="Building-a-Dataset"><a class="docs-heading-anchor" href="#Building-a-Dataset">Building a Dataset</a><a id="Building-a-Dataset-1"></a><a class="docs-heading-anchor-permalink" href="#Building-a-Dataset" title="Permalink"></a></h2><p>Now let&#39;s build a dataset from our ensemble model. We will make our dataset for <code>S</code>, <code>I</code>, and <code>R</code> by taking a linear combination of our models and using the aforementioned interface on the ensemble solution.</p><pre><code class="language- hljs">weights = [0.2, 0.5, 0.3]
data = [
    S =&gt; vec(sum(stack(weights .* sol[:,S]), dims = 2)),
    I =&gt; vec(sum(stack(weights .* sol[:,I]), dims = 2)),
    R =&gt; vec(sum(stack(weights .* sol[:,R]), dims = 2)),
]</code></pre><pre><code class="language- hljs">plot(sol; idxs = S)
scatter!(data[1][2])</code></pre><pre><code class="language- hljs">plot(sol; idxs = I)
scatter!(data[2][2])</code></pre><pre><code class="language- hljs">plot(sol; idxs = R)
scatter!(data[3][2])</code></pre><p>Now let&#39;s split that into training, ensembling, and forecast sections:</p><pre><code class="language- hljs">fullS = vec(sum(stack(weights .* sol[:,S]),dims=2))
fullI = vec(sum(stack(weights .* sol[:,I]),dims=2))
fullR = vec(sum(stack(weights .* sol[:,R]),dims=2))

t_train = 0:14
data_train = [
    S =&gt; (t_train,fullS[1:15]),
    I =&gt; (t_train,fullI[1:15]),
    R =&gt; (t_train,fullR[1:15]),
]
t_ensem = 0:21
data_ensem = [
    S =&gt; (t_ensem,fullS[1:22]),
    I =&gt; (t_ensem,fullI[1:22]),
    R =&gt; (t_ensem,fullR[1:22]),
]
t_forecast = 0:30
data_forecast = [
    S =&gt; (t_forecast,fullS),
    I =&gt; (t_forecast,fullI),
    R =&gt; (t_forecast,fullR),
]</code></pre><h2 id="Bayesian-Calibration"><a class="docs-heading-anchor" href="#Bayesian-Calibration">Bayesian Calibration</a><a id="Bayesian-Calibration-1"></a><a class="docs-heading-anchor-permalink" href="#Bayesian-Calibration" title="Permalink"></a></h2><p>Now let&#39;s perform a Bayesian calibration on each of the models. This gives us multiple parameterizations for each model, which then gives an ensemble which is <code>parameterizations x models</code> in size.</p><pre><code class="language- hljs">probs = [prob, prob2, prob3]
ps = [[β =&gt; Uniform(0.01, 10.0), γ =&gt; Uniform(0.01, 10.0)] for i in 1:3]
datas = [data_train,data_train,data_train]
enprobs = bayesian_ensemble(probs, ps, datas)</code></pre><p>Let&#39;s see how each of our models in the ensemble compare against the data when changed to use the fit parameters:</p><pre><code class="language- hljs">sol = solve(enprobs);

plot(sol; idxs = S)
scatter!(t_train, data_train[1][2][2])</code></pre><pre><code class="language- hljs">plot(sol; idxs = I)
scatter!(t_train, data_train[2][2][2])</code></pre><pre><code class="language- hljs">plot(sol; idxs = R)
scatter!(t_train, data_train[3][2][2])</code></pre><h2 id="Training-the-Ensemble-Model"><a class="docs-heading-anchor" href="#Training-the-Ensemble-Model">Training the Ensemble Model</a><a id="Training-the-Ensemble-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Training-the-Ensemble-Model" title="Permalink"></a></h2><p>Now let&#39;s train the ensemble model. We will do that by solving a bit further than the calibration step. Let&#39;s build that solution data:</p><pre><code class="language- hljs">plot(sol;idxs = S)
scatter!(t_ensem,data_ensem[1][2][2])</code></pre><p>We can obtain the optimal weights for ensembling by solving a linear regression of the solution&#39;s data against the wanted trajectory:</p><pre><code class="language- hljs">sol = solve(enprobs; saveat = t_ensem);
ensem_weights = ensemble_weights(sol, data_ensem)</code></pre><p>Now we can extrapolate forward with these ensemble weights as follows:</p><pre><code class="language- hljs">sol = solve(enprobs; saveat = t_ensem);
ensem_prediction = sum(stack(ensem_weights .* sol[:,S]), dims = 2)
plot(sol; idxs = S, color = :blue)
plot!(t_ensem, ensem_prediction, lw = 5, color = :red)
scatter!(t_ensem, data_ensem[1][2][2])</code></pre><pre><code class="language- hljs">ensem_prediction = sum(stack(ensem_weights .* sol[:,I]), dims = 2)
plot(sol; idxs = I, color = :blue)
plot!(t_ensem, ensem_prediction, lw = 3, color = :red)
scatter!(t_ensem, data_ensem[2][2][2])</code></pre><h2 id="Forecasting-the-Trained-Ensemble"><a class="docs-heading-anchor" href="#Forecasting-the-Trained-Ensemble">Forecasting the Trained Ensemble</a><a id="Forecasting-the-Trained-Ensemble-1"></a><a class="docs-heading-anchor-permalink" href="#Forecasting-the-Trained-Ensemble" title="Permalink"></a></h2><p>Once we have obtained the ensemble model, we can forecast ahead with it:</p><pre><code class="language- hljs">forecast_probs = [remake(enprobs.prob[i]; tspan = (t_train[1],t_forecast[end])) for i in 1:length(enprobs.prob)]
fit_enprob = EnsembleProblem(forecast_probs)

sol = solve(fit_enprob; saveat = t_forecast);
ensem_prediction = sum(stack(ensem_weights .* sol[:,S]), dims = 2)
plot(sol; idxs = S, color = :blue)
plot!(t_forecast, ensem_prediction, lw = 3, color = :red)
scatter!(t_forecast, data_forecast[1][2][2])</code></pre><pre><code class="language- hljs">ensem_prediction = sum(stack([ensem_weights[i] * sol[i][I] for i in 1:length(forecast_probs)]), dims = 2)
plot(sol; idxs = I, color = :blue)
plot!(t_forecast, ensem_prediction, lw = 3, color = :red)
scatter!(t_forecast, data_forecast[2][2][2])</code></pre><pre><code class="language- hljs">ensem_prediction = sum(stack([ensem_weights[i] * sol[i][R] for i in 1:length(forecast_probs)]), dims = 2)
plot(sol; idxs = R, color = :blue)
plot!(t_forecast, ensem_prediction, lw = 3, color = :red)
scatter!(t_forecast, data_forecast[3][2][2])</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../probabilistic_thresholds/">« Analysis of Threshold Crossing Probabilities Under Uncertainty</a><a class="docs-footer-nextpage" href="../../examples/petri/">AlgebraicPetri Integration »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Friday 9 February 2024 19:00">Friday 9 February 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
